#!/usr/bin/env python3

import argparse
import os
import re
import subprocess
import yaml

AUTOGEN_NOTICE='; THIS FILE IS GENERATED BY THE BUILD SCRIPT\n\n'

MODULE_TYPE_SRC=1
MODULE_TYPE_BIN=2

def add_checksum(path: str) -> None:
  with open(path, 'rb') as f:
    data = f.read()

  sum = 0
  for b in data:
    sum += b
  sum &= 0xff
  checksum = (-sum) & 0xff

  with open(path, 'ab') as f:
    f.write(bytes([checksum]))

def is_valid_module_name(name: str):
  for char in name:
    if not (char.isalpha() or char == '_'):
      return False
    return True

def get_base_directory() -> str:
  return os.path.dirname(os.path.abspath(__file__))

def get_args() -> argparse.Namespace:
  base_directory = get_base_directory()

  input = os.path.join(base_directory, 'src', 'magnolia.asm')
  output = os.path.join(base_directory, 'bin', 'magnolia.bin')

  parser = argparse.ArgumentParser(description='Magnolia build tool')

  parser.add_argument('-i', '--input', default=input,
                      help='path of the asm file to assemble')

  parser.add_argument('-o', '--output', default=output,
                      help='path of the output binary')

  return parser.parse_args()

def get_build_conf() -> tuple[int, str]:
  conf_path = os.path.join(get_base_directory(), 'build.yml')
  with open(conf_path, 'r') as f:
    data = yaml.load(f, Loader=yaml.SafeLoader)
  return data

def create_module(name: str, path: str, type: int) -> str:
  if not is_valid_module_name(name):
    raise ValueError(f'Invalid module name: {name}')
  
  if not (type == MODULE_TYPE_SRC or type == MODULE_TYPE_BIN):
    raise ValueError(f'Invalid module type: {name}')

  path = os.path.join(get_base_directory(), path)

  if type == MODULE_TYPE_BIN:
    if not os.path.isfile(path):
      raise ValueError(f'Module path must be a file for type \'bin\'')
    return path
  
  if not os.path.isdir(path):
    raise ValueError(f'Module path must be a directory for type \'src\'')

  make = subprocess.run(['make'], cwd=path)
  make.check_returncode()

  path = os.path.join(path, f'bin/{name}.bin')

  return path

def create_embeds(modules: list) -> str:
  embeds = AUTOGEN_NOTICE
  for module in modules:
    name = module['name'].upper()
    path = module['path']
    embeds += f'EMB_{name}: incbin "{path}"\n'
    embeds += f'EMB_{name}_SIZE equ ($ - EMB_{name})\n'
  return embeds

def create_metadata(metadata: dict) -> str:
  title_validation_re = "^[a-zA-Z0-9._\\-\\s]+$"

  content = AUTOGEN_NOTICE

  vendor = metadata['vendor']
  name = metadata['name']
  version = metadata['version']

  if type(metadata['vendor']) != str:
    raise ValueError('Missing required property: metadata.vendor')

  if type(metadata['name']) != str:
    raise ValueError('Missing required property: metadata.name')

  if type(metadata['version']) != str:
    raise ValueError('Missing required property: metadata.version')

  title = f'{vendor} {name} {version}'
  length = len(title)

  if not re.match(title_validation_re, title):
    raise ValueError('Metadata contains invalid characters')
  
  content += f'TITLE_DATA db DEFAULT_ATTR_HLGHT, {length}, \'{title}\''

  return content

def create_pci(pci: dict) -> str:
  content = AUTOGEN_NOTICE

  if not all(isinstance(value, int) for value in pci.values()):
    raise ValueError('PCI Vendor/Device ID and Class must be integers')
  
  content += f'PCI_VENDOR_ID equ {pci["vendor"]}\n'
  content += f'PCI_DEVICE_ID equ {pci["device"]}\n'
  content += f'PCI_CLASS     equ {pci["class"]}\n'
  content += f'PCI_SUBCLASS  equ {pci["subclass"]}\n'
  content += f'PCI_INTERFACE equ {pci["interface"]}\n'

  return content

def main() -> None:
  args = get_args()
  build_conf = get_build_conf()
  src_path = os.path.join(get_base_directory(), 'src')
  embeds_path = os.path.join(src_path, 'autogen', 'embeds.asm')
  metadata_path = os.path.join(src_path, 'autogen', 'metadata.asm')
  pci_path = os.path.join(src_path, 'autogen', 'pci.asm')
  modules = []

  for module in build_conf['modules']:
    name = module['name']
    path = module['path']
    type = 0

    if module['type'] == 'src':
      type = MODULE_TYPE_SRC
    
    if module['type'] == 'bin':
      type = MODULE_TYPE_BIN

    modules.append({ 'name': name, 'path': create_module(name, path, type) })

  with open(embeds_path, 'w') as f:
    f.write(create_embeds(modules))

  with open(metadata_path, 'w') as f:
    f.write(create_metadata(build_conf['metadata']))

  with open(pci_path, 'w') as f:
    f.write(create_pci(build_conf['pci']))

  assembler = subprocess.run(['nasm', '-f', 'bin', args.input, 
                              '-o', args.output], cwd=src_path)

  assembler.check_returncode()

  add_checksum(args.output)

if __name__ == '__main__':
  main()